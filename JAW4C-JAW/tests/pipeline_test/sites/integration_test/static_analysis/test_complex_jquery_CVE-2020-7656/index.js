// Complex test case for jQuery CVE-2020-7656 vulnerability
// Testing various call patterns for LIBOBJ(WILDCARD).html(PAYLOAD)

const $ = require('jquery');
const _ = require('lodash');
const moment = require('moment');
const axios = require('axios');

// Import dummy libraries
import { formatString, validateEmail, generateId } from './dummy-utils.js';
import { DataProcessor, createProcessor } from './dummy-data-processor.js';
import { ApiClient, createClient } from './dummy-api-client.js';

// Source: document.cookie (taint source)
const userInput = document.cookie;
const maliciousPayload = userInput + '&st=1';

// ========== Pattern 1: Direct call with selector ========== suc
// LIBOBJ(WILDCARD).html(PAYLOAD)
$("#main-content").html(maliciousPayload);

// ========== Pattern 2: Variable selector ========== suc
const targetSelector = "#result";
$(targetSelector).html(maliciousPayload);

// ========== Pattern 3: Dynamic selector construction ========== fail
const prefix = "#";
const elementId = "div-" + generateId();
const dynamicSelector = prefix + "container";
$(dynamicSelector).html(userInput);

// ========== Pattern 4: Chained call ========== suc
$("#alert-box").fadeIn().html(maliciousPayload).fadeOut(); // Should not be detected

// ========== Pattern 5: Method call on stored jQuery object ========== suc
const $element = $("#target");
$element.html(maliciousPayload);

// ========== Pattern 6: Array/Object traversal ========== suc
const elements = {
    main: $("#main"),
    sidebar: $("#sidebar"),
    footer: $("#footer")
};
elements.sidebar.html(userInput); // suc

// ========== Pattern 7: Function return value ========== suc
function getElement(id) {
    return $("#" + id);
}
getElement("dangerous").html(maliciousPayload);
 
// ========== Pattern 8: Conditional execution ========== suc
const shouldRender = true;
if (shouldRender) {
    $("#conditional-div").html(userInput); // suc
}

// ========== Pattern 9: Loop iteration ========== suc
const divIds = ["div1", "div2", "div3"];
for (let i = 0; i < divIds.length; i++) {
    $("#" + divIds[i]).html(maliciousPayload);
}

// ========== Pattern 10: Lodash integration ========== fail
const targets = ["#target1", "#target2"];
_.forEach(targets, function(selector) {
    $(selector).html(userInput);
});

// ========== Pattern 11: Nested function calls ========== fail
function processAndRender(data) {
    const processed = formatString(data);
    return function(selector) {
        $(selector).html(processed);
    };
}
processAndRender(userInput)("#nested");

// ========== Pattern 12: Promise/async pattern ========== fail
async function fetchAndRender() {
    const data = userInput; // In real scenario, this might be from axios
    $("#async-content").html(data);
}
fetchAndRender();

// ========== Pattern 13: Event handler ========== suc
$(document).ready(function() {
    $("#button").click(function() {
        const eventData = document.cookie;
        $("#event-result").html(eventData);
    });
});

// ========== Pattern 14: jQuery find with html ========== suc (failed but logically okay)
$("#container").find(".inner").html(maliciousPayload);

// ========== Pattern 15: Multiple transformations ========== // suc
const rawData = document.cookie;
const step1 = rawData + "&param=1";
const step2 = step1.replace(/\s/g, "+");
const step3 = step2 + "&final=true";
$("#multi-step").html(step3); // suc

// ========== Pattern 16: Object method call ========== // fail
const renderer = {
    target: "#render-target",
    render: function(content) {
        $(this.target).html(content);
    }
};
renderer.render(maliciousPayload);

// ========== Pattern 17: Array destructuring ========== // fail
const [first, second] = ["#first", "#second"];
$(first).html(userInput);

// ========== Pattern 18: Template literal ========== // suc
const dynamicId = "template";
$(`#${dynamicId}-div`).html(maliciousPayload); // suc

// ========== Pattern 19: jQuery each ========== // fail
$(".vuln-class").each(function() {
    $(this).html(userInput);
});

// ========== Pattern 20: Moment.js integration with taint flow ========== // suc
const timestamp = moment().format();
const combined = userInput + " at " + timestamp;
$("#timestamp-div").html(combined);

// ========== Safe usage examples (should not trigger) ========== 
// These should NOT be detected as vulnerable
$("#safe1").text(userInput); // Using .text() instead of .html()
$("#safe2").html("<p>Static content</p>"); // Static string, not tainted suc // suc
const sanitized = validateEmail(userInput) ? "valid" : "invalid"; // false positive
$("#safe3").html(sanitized); // Sanitized/validated

// ========== Use dummy libraries to ensure they're bundled ==========
const processor = createProcessor();
processor.addData(userInput);
const processed = processor.processData();
console.log("Processed data:", processed);

const client = createClient("https://api.example.com");
client.setHeader("Authorization", "Bearer token");
console.log("API client created");

console.log("Test case loaded - jQuery CVE-2020-7656 vulnerability patterns");
